---
title: カンバンボード（Trelloライク）
description: ドラッグ&ドロップ対応の本格的なカンバンボード。タスク管理、プロジェクト管理、ワークフロー可視化に最適。
tags: [kanban, drag-drop, task-management, workflow, productivity]
frameworks: [Vanilla, Any]
level: advanced
prompt_template: |
  プロダクション品質のカンバンボードを実装。要件：
  - 3カラム構成（Todo、In Progress、Done）
  - ドラッグ&ドロップでカード移動（HTML5 Drag & Drop API使用）
  - カード追加機能（各カラムに追加ボタン）
  - カード編集機能（クリックでインライン編集）
  - カード削除機能（削除ボタン）
  - カラムごとのカード数カウンター
  - ドラッグ中の視覚フィードバック（ゴーストカード、ドロップゾーンハイライト）
  - キーボードサポート（Alt + 矢印キーでカード移動）
  - ARIA live regions（スクリーンリーダー対応）
  - LocalStorage永続化（リロード後も状態保持）
  - レスポンシブ（モバイルでは縦積み、ドラッグ&ドロップも動作）
---

import LiveDemo from '../../components/LiveDemo.astro';

<LiveDemo
  title="カンバンボードのデモ（ドラッグ&ドロップでカード移動）"
  height="700px"
  html={`
<div class="kanban-board">
  <!-- ARIA live region for screen readers -->
  <div class="sr-only" role="status" aria-live="polite" aria-atomic="true" id="kanban-status"></div>

  <div class="kanban-header">
    <h2>プロジェクト管理ボード</h2>
    <button class="btn-reset" onclick="window.kanbanInstance.resetBoard()">ボードをリセット</button>
  </div>

  <div class="kanban-columns">
    <!-- Todo Column -->
    <div class="kanban-column" data-column="todo">
      <div class="column-header">
        <div class="column-title">
          <span class="column-icon">📋</span>
          <h3>Todo</h3>
          <span class="card-count">0</span>
        </div>
        <button class="btn-add-card" onclick="window.kanbanInstance.addCard('todo')">+ 追加</button>
      </div>
      <div class="cards-container" data-column-id="todo">
        <!-- Cards will be inserted here -->
      </div>
    </div>

    <!-- In Progress Column -->
    <div class="kanban-column" data-column="in-progress">
      <div class="column-header">
        <div class="column-title">
          <span class="column-icon">⚙️</span>
          <h3>In Progress</h3>
          <span class="card-count">0</span>
        </div>
        <button class="btn-add-card" onclick="window.kanbanInstance.addCard('in-progress')">+ 追加</button>
      </div>
      <div class="cards-container" data-column-id="in-progress">
        <!-- Cards will be inserted here -->
      </div>
    </div>

    <!-- Done Column -->
    <div class="kanban-column" data-column="done">
      <div class="column-header">
        <div class="column-title">
          <span class="column-icon">✅</span>
          <h3>Done</h3>
          <span class="card-count">0</span>
        </div>
        <button class="btn-add-card" onclick="window.kanbanInstance.addCard('done')">+ 追加</button>
      </div>
      <div class="cards-container" data-column-id="done">
        <!-- Cards will be inserted here -->
      </div>
    </div>
  </div>

  <div class="kanban-help">
    <p>💡 ヒント: カードをドラッグして移動 | ダブルクリックで編集 | Alt + ←→ でキーボード移動</p>
  </div>
</div>
  `}
  css={`
/* Screen reader only */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.kanban-board {
  width: 100%;
  background: #0c1218;
  border-radius: 12px;
  padding: 20px;
  min-height: 600px;
}

.kanban-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 2px solid #1f2a37;
}

.kanban-header h2 {
  color: #e5edf4;
  font-size: 24px;
  font-weight: 700;
  margin: 0;
}

.btn-reset {
  padding: 8px 16px;
  background: #374151;
  border: 1px solid #4b5563;
  border-radius: 6px;
  color: #e5edf4;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-reset:hover {
  background: #4b5563;
  border-color: #60a5fa;
}

.kanban-columns {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  margin-bottom: 20px;
}

.kanban-column {
  background: #1f2a37;
  border-radius: 12px;
  padding: 16px;
  min-height: 400px;
  display: flex;
  flex-direction: column;
}

.column-header {
  margin-bottom: 16px;
}

.column-title {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
}

.column-icon {
  font-size: 20px;
}

.column-title h3 {
  color: #e5edf4;
  font-size: 18px;
  font-weight: 600;
  margin: 0;
  flex: 1;
}

.card-count {
  background: #374151;
  color: #9ca3af;
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
}

.btn-add-card {
  width: 100%;
  padding: 8px;
  background: #0c1218;
  border: 2px dashed #374151;
  border-radius: 8px;
  color: #9ca3af;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-add-card:hover {
  border-color: #60a5fa;
  color: #60a5fa;
  background: #1a2332;
}

.cards-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 12px;
  min-height: 100px;
  padding: 8px;
  border-radius: 8px;
  transition: background 0.2s;
}

.cards-container.drag-over {
  background: #1a2332;
  outline: 2px dashed #60a5fa;
  outline-offset: -4px;
}

.kanban-card {
  background: #0c1218;
  border: 1px solid #374151;
  border-radius: 8px;
  padding: 12px;
  cursor: move;
  transition: all 0.2s;
  position: relative;
}

.kanban-card:hover {
  border-color: #60a5fa;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(96, 165, 250, 0.15);
}

.kanban-card:focus-visible {
  outline: 2px solid #60a5fa;
  outline-offset: 2px;
}

.kanban-card.dragging {
  opacity: 0.5;
  transform: rotate(5deg);
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 8px;
}

.card-content {
  color: #e5edf4;
  font-size: 14px;
  line-height: 1.5;
  word-wrap: break-word;
  min-height: 20px;
}

.card-content:empty::before {
  content: '新しいカード';
  color: #6b7280;
  font-style: italic;
}

.card-editing {
  width: 100%;
  background: #1f2a37;
  border: 1px solid #60a5fa;
  border-radius: 4px;
  color: #e5edf4;
  font-size: 14px;
  padding: 8px;
  resize: vertical;
  min-height: 60px;
  font-family: inherit;
}

.card-editing:focus {
  outline: none;
  border-color: #60a5fa;
}

.card-actions {
  display: flex;
  gap: 4px;
}

.btn-card-action {
  padding: 4px 6px;
  background: transparent;
  border: none;
  border-radius: 4px;
  color: #9ca3af;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.2s;
  line-height: 1;
}

.btn-card-action:hover {
  background: #374151;
  color: #e5edf4;
}

.btn-delete:hover {
  color: #f87171;
}

.card-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid #374151;
  font-size: 11px;
  color: #6b7280;
}

.card-id {
  font-family: monospace;
}

.card-timestamp {
  font-style: italic;
}

.kanban-help {
  text-align: center;
  padding: 16px;
  background: #1f2a37;
  border-radius: 8px;
  color: #9ca3af;
  font-size: 13px;
}

/* Mobile responsive */
@media (max-width: 768px) {
  .kanban-columns {
    grid-template-columns: 1fr;
  }

  .kanban-column {
    min-height: 200px;
  }

  .kanban-header {
    flex-direction: column;
    gap: 12px;
    align-items: stretch;
  }

  .btn-reset {
    width: 100%;
  }
}

/* Animation */
@keyframes cardAdded {
  from {
    opacity: 0;
    transform: scale(0.9) translateY(-10px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.kanban-card.just-added {
  animation: cardAdded 0.3s ease-out;
}
  `}
  js={`
class KanbanBoard {
  constructor() {
    this.boards = this.loadFromStorage() || {
      'todo': [
        { id: 1, content: 'デザインモックアップを作成する', created: new Date().toISOString() },
        { id: 2, content: 'APIエンドポイントの設計を確認', created: new Date().toISOString() },
      ],
      'in-progress': [
        { id: 3, content: 'ユーザー認証機能の実装', created: new Date().toISOString() },
      ],
      'done': [
        { id: 4, content: 'プロジェクトのセットアップ完了', created: new Date().toISOString() },
      ]
    };
    this.nextId = this.getMaxId() + 1;
    this.draggedCard = null;
    this.currentlyEditing = null;

    this.init();
  }

  init() {
    this.bindDragEvents();
    this.bindKeyboardEvents();
    this.render();
  }

  getMaxId() {
    let maxId = 0;
    Object.values(this.boards).forEach(cards => {
      cards.forEach(card => {
        if (card.id > maxId) maxId = card.id;
      });
    });
    return maxId;
  }

  bindDragEvents() {
    // Delegation for drag events
    document.addEventListener('dragstart', (e) => {
      if (e.target.classList.contains('kanban-card')) {
        this.handleDragStart(e);
      }
    });

    document.addEventListener('dragend', (e) => {
      if (e.target.classList.contains('kanban-card')) {
        this.handleDragEnd(e);
      }
    });

    document.addEventListener('dragover', (e) => {
      if (e.target.closest('.cards-container')) {
        this.handleDragOver(e);
      }
    });

    document.addEventListener('drop', (e) => {
      if (e.target.closest('.cards-container')) {
        this.handleDrop(e);
      }
    });

    document.addEventListener('dragleave', (e) => {
      if (e.target.classList.contains('cards-container')) {
        this.handleDragLeave(e);
      }
    });
  }

  bindKeyboardEvents() {
    document.addEventListener('keydown', (e) => {
      // Alt + Arrow keys for card movement
      if (e.altKey && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
        const focusedCard = document.activeElement.closest('.kanban-card');
        if (focusedCard) {
          e.preventDefault();
          this.moveCardWithKeyboard(focusedCard, e.key);
        }
      }
    });
  }

  handleDragStart(e) {
    const card = e.target;
    this.draggedCard = {
      element: card,
      id: parseInt(card.dataset.cardId),
      fromColumn: card.closest('.cards-container').dataset.columnId
    };

    card.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', card.innerHTML);
  }

  handleDragEnd(e) {
    e.target.classList.remove('dragging');
    document.querySelectorAll('.cards-container').forEach(container => {
      container.classList.remove('drag-over');
    });
  }

  handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';

    const container = e.target.closest('.cards-container');
    if (container && !container.classList.contains('drag-over')) {
      document.querySelectorAll('.cards-container').forEach(c => c.classList.remove('drag-over'));
      container.classList.add('drag-over');
    }
  }

  handleDragLeave(e) {
    if (e.target.classList.contains('cards-container')) {
      e.target.classList.remove('drag-over');
    }
  }

  handleDrop(e) {
    e.preventDefault();
    e.stopPropagation();

    const container = e.target.closest('.cards-container');
    if (!container || !this.draggedCard) return;

    container.classList.remove('drag-over');

    const toColumn = container.dataset.columnId;
    const fromColumn = this.draggedCard.fromColumn;
    const cardId = this.draggedCard.id;

    if (fromColumn !== toColumn) {
      // Find and remove card from source column
      const cardIndex = this.boards[fromColumn].findIndex(c => c.id === cardId);
      if (cardIndex !== -1) {
        const [card] = this.boards[fromColumn].splice(cardIndex, 1);
        this.boards[toColumn].push(card);

        this.announceMove(card.content, fromColumn, toColumn);
        this.saveToStorage();
        this.render();
      }
    }

    this.draggedCard = null;
  }

  moveCardWithKeyboard(cardElement, direction) {
    const cardId = parseInt(cardElement.dataset.cardId);
    const currentColumn = cardElement.closest('.cards-container').dataset.columnId;
    const columns = ['todo', 'in-progress', 'done'];
    const currentIndex = columns.indexOf(currentColumn);

    let targetColumn;
    if (direction === 'ArrowLeft' && currentIndex > 0) {
      targetColumn = columns[currentIndex - 1];
    } else if (direction === 'ArrowRight' && currentIndex < columns.length - 1) {
      targetColumn = columns[currentIndex + 1];
    }

    if (targetColumn && targetColumn !== currentColumn) {
      const cardIndex = this.boards[currentColumn].findIndex(c => c.id === cardId);
      if (cardIndex !== -1) {
        const [card] = this.boards[currentColumn].splice(cardIndex, 1);
        this.boards[targetColumn].push(card);

        this.announceMove(card.content, currentColumn, targetColumn);
        this.saveToStorage();
        this.render();

        // Re-focus the moved card
        setTimeout(() => {
          const movedCard = document.querySelector(\`[data-card-id="\${cardId}"]\`);
          if (movedCard) movedCard.focus();
        }, 100);
      }
    }
  }

  addCard(columnId) {
    const newCard = {
      id: this.nextId++,
      content: '',
      created: new Date().toISOString()
    };

    this.boards[columnId].push(newCard);
    this.saveToStorage();
    this.render();

    // Auto-focus the new card for editing
    setTimeout(() => {
      const cardElement = document.querySelector(\`[data-card-id="\${newCard.id}"]\`);
      if (cardElement) {
        this.editCard(newCard.id, columnId);
        cardElement.classList.add('just-added');
        setTimeout(() => cardElement.classList.remove('just-added'), 300);
      }
    }, 50);

    this.announce(\`新しいカードを\${this.getColumnName(columnId)}に追加しました\`);
  }

  deleteCard(cardId, columnId) {
    const cardIndex = this.boards[columnId].findIndex(c => c.id === cardId);
    if (cardIndex !== -1) {
      const card = this.boards[columnId][cardIndex];
      if (confirm(\`カード「\${card.content || '新しいカード'}」を削除しますか？\`)) {
        this.boards[columnId].splice(cardIndex, 1);
        this.saveToStorage();
        this.render();
        this.announce(\`カードを削除しました\`);
      }
    }
  }

  editCard(cardId, columnId) {
    if (this.currentlyEditing) {
      this.saveEdit();
    }

    this.currentlyEditing = { cardId, columnId };
    const card = this.boards[columnId].find(c => c.id === cardId);

    const cardElement = document.querySelector(\`[data-card-id="\${cardId}"]\`);
    const contentDiv = cardElement.querySelector('.card-content');

    const textarea = document.createElement('textarea');
    textarea.className = 'card-editing';
    textarea.value = card.content;
    textarea.dataset.cardId = cardId;
    textarea.dataset.columnId = columnId;

    contentDiv.replaceWith(textarea);
    textarea.focus();
    textarea.select();

    textarea.addEventListener('blur', () => this.saveEdit());
    textarea.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this.cancelEdit();
      } else if (e.key === 'Enter' && e.ctrlKey) {
        this.saveEdit();
      }
    });
  }

  saveEdit() {
    if (!this.currentlyEditing) return;

    const { cardId, columnId } = this.currentlyEditing;
    const textarea = document.querySelector(\`.card-editing[data-card-id="\${cardId}"]\`);

    if (textarea) {
      const card = this.boards[columnId].find(c => c.id === cardId);
      card.content = textarea.value.trim();
      this.saveToStorage();
    }

    this.currentlyEditing = null;
    this.render();
  }

  cancelEdit() {
    this.currentlyEditing = null;
    this.render();
  }

  render() {
    Object.keys(this.boards).forEach(columnId => {
      const container = document.querySelector(\`.cards-container[data-column-id="\${columnId}"]\`);
      const cards = this.boards[columnId];

      // Update card count
      const countBadge = container.closest('.kanban-column').querySelector('.card-count');
      countBadge.textContent = cards.length;

      // Render cards
      container.innerHTML = cards.map(card => \`
        <div class="kanban-card"
             draggable="true"
             data-card-id="\${card.id}"
             tabindex="0"
             role="article"
             aria-label="カード: \${card.content || '新しいカード'}">
          <div class="card-header">
            <div class="card-actions">
              <button class="btn-card-action btn-delete"
                      onclick="window.kanbanInstance.deleteCard(\${card.id}, '\${columnId}')"
                      aria-label="削除"
                      title="削除">🗑️</button>
            </div>
          </div>
          <div class="card-content" ondblclick="window.kanbanInstance.editCard(\${card.id}, '\${columnId}')">\${card.content}</div>
          <div class="card-footer">
            <span class="card-id">#\${card.id}</span>
            <span class="card-timestamp">\${this.formatDate(card.created)}</span>
          </div>
        </div>
      \`).join('');
    });
  }

  formatDate(isoString) {
    const date = new Date(isoString);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return '今';
    if (diffMins < 60) return \`\${diffMins}分前\`;
    if (diffHours < 24) return \`\${diffHours}時間前\`;
    if (diffDays < 7) return \`\${diffDays}日前\`;

    return date.toLocaleDateString('ja-JP', { month: 'short', day: 'numeric' });
  }

  getColumnName(columnId) {
    const names = {
      'todo': 'Todo',
      'in-progress': 'In Progress',
      'done': 'Done'
    };
    return names[columnId] || columnId;
  }

  announce(message) {
    const status = document.getElementById('kanban-status');
    status.textContent = message;
    setTimeout(() => status.textContent = '', 3000);
  }

  announceMove(cardContent, fromColumn, toColumn) {
    const message = \`カード「\${cardContent}」を\${this.getColumnName(fromColumn)}から\${this.getColumnName(toColumn)}に移動しました\`;
    this.announce(message);
  }

  saveToStorage() {
    try {
      localStorage.setItem('kanban-board', JSON.stringify(this.boards));
    } catch (e) {
      console.error('Failed to save to localStorage:', e);
    }
  }

  loadFromStorage() {
    try {
      const data = localStorage.getItem('kanban-board');
      return data ? JSON.parse(data) : null;
    } catch (e) {
      console.error('Failed to load from localStorage:', e);
      return null;
    }
  }

  resetBoard() {
    if (confirm('ボードをリセットしますか？すべてのカードが初期状態に戻ります。')) {
      localStorage.removeItem('kanban-board');
      location.reload();
    }
  }
}

// Initialize
const kanban = new KanbanBoard();
window.kanbanInstance = kanban;
  `}
/>

## 概要

Trelloライクの本格的なカンバンボードコンポーネントです。HTML5 Drag & Drop APIを使用したスムーズなカード移動、インライン編集、LocalStorageによる永続化など、プロダクション環境で必要な機能を全て実装しています。タスク管理、プロジェクト管理、ワークフロー可視化など、様々なシーンで活用できます。

ドラッグ&ドロップだけでなく、キーボード操作（Alt + 矢印キー）やARIA live regionsによるスクリーンリーダー対応も完備。モバイルではカラムが縦積みになり、ドラッグ&ドロップも正常に動作するため、あらゆるデバイスで快適に使用できます。

## 主要機能

### カード操作
- **ドラッグ&ドロップ**: カードをつかんで別のカラムにドロップ
- **カード追加**: 各カラムに追加ボタン（空のカードを作成）
- **インライン編集**: カードをダブルクリックで編集モード（Ctrl+Enterで保存、Escでキャンセル）
- **カード削除**: 各カードに削除ボタン（確認ダイアログ付き）
- **カウンター**: 各カラムのカード数を表示

### ユーザビリティ
- **視覚フィードバック**: ドラッグ中のゴーストエフェクト、ドロップゾーンハイライト
- **キーボード操作**: Alt + ←/→ でカード移動（フォーカス中のカード）
- **アクセシビリティ**: ARIA live regions、role属性、aria-label完備
- **永続化**: LocalStorageで状態保存（リロード後も復元）

### レスポンシブ
- **デスクトップ**: 3カラム横並び
- **モバイル**: カラム縦積み、タッチデバイスでもドラッグ可能
- **アニメーション**: カード追加時のフェードイン

## データ構造

### ボードデータ

```javascript
{
  'todo': [
    {
      id: 1,
      content: 'デザインモックアップを作成する',
      created: '2025-11-11T10:30:00.000Z'
    },
    // ... more cards
  ],
  'in-progress': [ /* cards */ ],
  'done': [ /* cards */ ]
}
```

### カードプロパティ
- **id**: ユニークなカードID（数値、自動採番）
- **content**: カードのテキスト内容（Markdown未対応、プレーンテキスト）
- **created**: 作成日時（ISO 8601形式）

## 実装コード

完全なプロダクション対応の実装です。そのままプロジェクトに組み込んで使用できます。

### HTML構造

```html
<div class="kanban-board">
  <!-- ARIA live region -->
  <div class="sr-only" role="status" aria-live="polite" id="kanban-status"></div>

  <div class="kanban-header">
    <h2>プロジェクト管理ボード</h2>
    <button class="btn-reset">ボードをリセット</button>
  </div>

  <div class="kanban-columns">
    <div class="kanban-column" data-column="todo">
      <div class="column-header">
        <div class="column-title">
          <span class="column-icon">📋</span>
          <h3>Todo</h3>
          <span class="card-count">0</span>
        </div>
        <button class="btn-add-card">+ 追加</button>
      </div>
      <div class="cards-container" data-column-id="todo">
        <!-- カードがここに挿入される -->
      </div>
    </div>
    <!-- 他のカラム... -->
  </div>
</div>
```

### JavaScript実装

```javascript
class KanbanBoard {
  constructor() {
    this.boards = this.loadFromStorage() || {
      'todo': [],
      'in-progress': [],
      'done': []
    };
    this.draggedCard = null;
    this.init();
  }

  // ドラッグ開始
  handleDragStart(e) {
    const card = e.target;
    this.draggedCard = {
      element: card,
      id: parseInt(card.dataset.cardId),
      fromColumn: card.closest('.cards-container').dataset.columnId
    };
    card.classList.add('dragging');
  }

  // ドロップ処理
  handleDrop(e) {
    e.preventDefault();
    const toColumn = e.target.closest('.cards-container').dataset.columnId;
    const fromColumn = this.draggedCard.fromColumn;

    if (fromColumn !== toColumn) {
      // カードを移動
      const cardIndex = this.boards[fromColumn].findIndex(c => c.id === this.draggedCard.id);
      const [card] = this.boards[fromColumn].splice(cardIndex, 1);
      this.boards[toColumn].push(card);

      this.saveToStorage();
      this.render();
    }
  }

  // LocalStorageに保存
  saveToStorage() {
    localStorage.setItem('kanban-board', JSON.stringify(this.boards));
  }

  // LocalStorageから読み込み
  loadFromStorage() {
    const data = localStorage.getItem('kanban-board');
    return data ? JSON.parse(data) : null;
  }
}
```

## アクセシビリティ考慮事項

### ARIA属性
- **role="status" aria-live="polite"**: カード移動時の状態変更をスクリーンリーダーに通知
- **role="article"**: 各カードをarticleとして認識
- **aria-label**: カード内容や操作ボタンの説明

### キーボード操作
- **Tab**: フォーカス移動
- **Alt + ←/→**: カードを前後のカラムに移動
- **Enter/Space**: カード選択（フォーカス時）
- **Escape**: 編集キャンセル
- **Ctrl + Enter**: 編集保存

### スクリーンリーダー対応
- **ARIA live regions**: カード移動や追加時にアナウンス
- **セマンティックHTML**: 見出し（h2, h3）、ボタン、適切なaria-label
- **フォーカス管理**: カード追加後や移動後に適切なフォーカス

## パフォーマンス最適化

### レンダリング最適化
1. **イベント委譲**: ドラッグイベントはdocumentレベルで一括管理
2. **innerHTML一括生成**: カードリストをループ外で一括生成
3. **選択的レンダリング**: 編集時は該当カードのみ更新（部分的にはテンプレート差し替え）

### メモリ管理
1. **イベントリスナー**: 委譲パターンで個別リスナー不要
2. **LocalStorage**: JSONシリアライズで軽量保存
3. **参照管理**: draggedCardはドラッグ中のみ保持

### スケーラビリティ
- **推奨カード数**: 各カラム〜50枚（合計150枚程度）
- **最大実用**: 各カラム〜100枚（DOM操作がやや重くなる）
- **超大規模**: 仮想スクロール導入を検討

## よくあるユースケース

### プロジェクト管理
- **タスクトラッキング**: 機能開発のステータス管理
- **スプリント計画**: アジャイル開発のバックログ管理
- **バグ管理**: 発見→対応中→修正済みの流れ

### ワークフロー可視化
- **営業パイプライン**: リード→商談→成約
- **採用フロー**: 応募→面接→内定
- **コンテンツ制作**: 企画→執筆→公開

### 個人タスク管理
- **GTD**: 次にやること→今やっていること→完了
- **習慣トラッカー**: 今日やる→進行中→達成
- **学習管理**: 未学習→学習中→理解済み

## 拡張とカスタマイズのアイデア

### 機能追加
1. **優先度ラベル**: カードに色付きラベル追加（高/中/低）
2. **担当者アサイン**: カードにアバター表示
3. **期限設定**: デッドライン表示と期限切れ警告
4. **コメント機能**: カードごとのコメントスレッド
5. **添付ファイル**: 画像やファイルの添付
6. **カラムカスタマイズ**: カラム追加/削除/並び替え

### UI改善
1. **カードテンプレート**: 定型フォーマットで新規作成
2. **カラーテーマ**: カラムごとに色分け
3. **アニメーション強化**: カード移動時のスムーズな遷移
4. **検索機能**: カード内容で全体検索
5. **フィルター**: 担当者や優先度でフィルタリング

### データ連携
1. **バックエンド同期**: REST APIやGraphQLで永続化
2. **リアルタイム共有**: WebSocketで複数ユーザー対応
3. **エクスポート**: JSON/CSV形式でデータダウンロード
4. **インポート**: Trello/Asana等からデータ移行
