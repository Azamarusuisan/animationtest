---
title: スクロールリビール
description: IntersectionObserver を使った段階的な要素表示アニメーション
tags: [animation, scroll, performance, intersection-observer]
frameworks: [Vanilla JS, React, Vue]
level: intermediate
demo_url: ""
code_url: ""
prompt_template: |
  次の要件でスクロールリビールアニメーションを実装してください。

  フレームワーク: {{framework}}（デフォルト: Vanilla JS）

  要件:
  - IntersectionObserver を使用（パフォーマンス重視）
  - threshold: 0.2（要素の20%が表示されたら発火）
  - トランジション: transform と opacity のみ使用
  - 1度発火した要素は監視解除
  - prefers-reduced-motion でフェードのみ（スライドなし）
  - カスタマイズ可能な遅延時間（staggered animation 対応）

  納品物:
  - 実装コード（関数またはコンポーネント）
  - 使用例
  - CSS（初期状態とアニメーション後の状態）
---

## 概要

スクロール時に要素を段階的に表示するアニメーション効果です。
IntersectionObserver API を使用することで、パフォーマンスを落とさずに実装できます。

## 実装のポイント

### 1. IntersectionObserver の利点

- スクロールイベントと比較して、パフォーマンスが大幅に向上
- ブラウザが最適なタイミングで検出
- メモリ効率が良い（監視解除が容易）

### 2. アニメーション設計

```css
/* 初期状態 */
.reveal {
  opacity: 0;
  transform: translateY(30px);
  transition: opacity 0.6s ease-out, transform 0.6s ease-out;
}

/* 表示後 */
.reveal.is-visible {
  opacity: 1;
  transform: translateY(0);
}

/* prefers-reduced-motion 対応 */
@media (prefers-reduced-motion: reduce) {
  .reveal {
    transform: none;
    transition: opacity 0.3s ease-out;
  }
}
```

### 3. パフォーマンス最適化

- 1度表示された要素は監視解除
- `will-change` の適切な使用
- transform と opacity のみを使用（GPU アクセラレーション）

<LiveDemo title="Advanced Scroll Reveal Demo" height="600px">
{`
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0c1218;
      color: #e5edf4;
      overflow-x: hidden;
    }

    .hero {
      min-height: 60vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 2rem;
      background: linear-gradient(135deg, #1f2a37 0%, #0c1218 100%);
    }

    .hero h1 {
      font-size: clamp(2rem, 5vw, 3.5rem);
      color: #60a5fa;
      margin-bottom: 1rem;
    }

    .hero p {
      font-size: 1.125rem;
      opacity: 0.8;
    }

    .content {
      max-width: 1000px;
      margin: 0 auto;
      padding: 3rem 1.5rem;
    }

    .reveal {
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
    }

    .reveal.is-visible {
      opacity: 1;
      transform: translateY(0);
    }

    .reveal-left {
      opacity: 0;
      transform: translateX(-50px);
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
    }

    .reveal-left.is-visible {
      opacity: 1;
      transform: translateX(0);
    }

    .reveal-right {
      opacity: 0;
      transform: translateX(50px);
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
    }

    .reveal-right.is-visible {
      opacity: 1;
      transform: translateX(0);
    }

    .reveal-scale {
      opacity: 0;
      transform: scale(0.8);
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
    }

    .reveal-scale.is-visible {
      opacity: 1;
      transform: scale(1);
    }

    .section-title {
      font-size: 2rem;
      color: #60a5fa;
      margin: 3rem 0 2rem;
      text-align: center;
    }

    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
      margin-bottom: 3rem;
    }

    .card {
      background: #1f2a37;
      border: 1px solid #374151;
      border-radius: 12px;
      padding: 2rem;
    }

    .card h3 {
      font-size: 1.25rem;
      color: #60a5fa;
      margin-bottom: 0.75rem;
    }

    .card p {
      line-height: 1.6;
      opacity: 0.9;
    }

    .feature-box {
      background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
      border-radius: 12px;
      padding: 3rem;
      margin: 2rem 0;
      text-align: center;
    }

    .feature-box h2 {
      font-size: 1.75rem;
      margin-bottom: 1rem;
    }

    @media (prefers-reduced-motion: reduce) {
      .reveal,
      .reveal-left,
      .reveal-right,
      .reveal-scale {
        transform: none;
        transition: opacity 0.3s ease-out;
      }
    }
  </style>
</head>
<body>
  <div class="hero">
    <h1>Scroll Reveal Animations</h1>
    <p>Multiple animation directions with IntersectionObserver</p>
  </div>

  <div class="content">
    <h2 class="reveal section-title">From Bottom</h2>

    <div class="card-grid">
      <div class="reveal card">
        <h3>Feature 1</h3>
        <p>Smooth fade-in animation from bottom with optimized performance.</p>
      </div>

      <div class="reveal card">
        <h3>Feature 2</h3>
        <p>Uses IntersectionObserver for efficient scroll detection.</p>
      </div>

      <div class="reveal card">
        <h3>Feature 3</h3>
        <p>GPU-accelerated transforms for buttery smooth animations.</p>
      </div>
    </div>

    <h2 class="reveal section-title">From Sides</h2>

    <div class="card-grid">
      <div class="reveal-left card">
        <h3>From Left</h3>
        <p>This card slides in from the left side with a fade effect.</p>
      </div>

      <div class="reveal-right card">
        <h3>From Right</h3>
        <p>This card slides in from the right side with a fade effect.</p>
      </div>
    </div>

    <div class="reveal-scale feature-box">
      <h2>Scale Animation</h2>
      <p>This element scales up from 80% to 100% while fading in</p>
    </div>

    <h2 class="reveal section-title">Staggered Grid</h2>

    <div class="card-grid">
      <div class="reveal card" style="transition-delay: 0s;">
        <h3>Card 1</h3>
        <p>No delay</p>
      </div>

      <div class="reveal card" style="transition-delay: 0.1s;">
        <h3>Card 2</h3>
        <p>0.1s delay</p>
      </div>

      <div class="reveal card" style="transition-delay: 0.2s;">
        <h3>Card 3</h3>
        <p>0.2s delay</p>
      </div>

      <div class="reveal card" style="transition-delay: 0.3s;">
        <h3>Card 4</h3>
        <p>0.3s delay</p>
      </div>
    </div>
  </div>

  <script>
    function initScrollReveal(options = {}) {
      const {
        selector = '.reveal, .reveal-left, .reveal-right, .reveal-scale',
        threshold = 0.2,
        rootMargin = '0px'
      } = options;

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('is-visible');
            observer.unobserve(entry.target);
          }
        });
      }, {
        threshold,
        rootMargin
      });

      const elements = document.querySelectorAll(selector);
      elements.forEach(el => observer.observe(el));

      return observer;
    }

    document.addEventListener('DOMContentLoaded', () => {
      initScrollReveal({
        threshold: 0.2
      });
    });
  </script>
</body>
</html>
`}
</LiveDemo>

## コード例

### Vanilla JavaScript

```javascript
// スクロールリビールの初期化
function initScrollReveal(options = {}) {
  const {
    selector = '.reveal',
    threshold = 0.2,
    rootMargin = '0px'
  } = options;

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        // 要素を表示
        entry.target.classList.add('is-visible');

        // 監視を解除（パフォーマンス向上）
        observer.unobserve(entry.target);
      }
    });
  }, {
    threshold,
    rootMargin
  });

  // 対象要素を監視開始
  const elements = document.querySelectorAll(selector);
  elements.forEach(el => observer.observe(el));

  return observer;
}

// 使用例
document.addEventListener('DOMContentLoaded', () => {
  initScrollReveal({
    selector: '.reveal',
    threshold: 0.2
  });
});
```

### React Hook

```jsx
import { useEffect, useRef } from 'react';

export function useScrollReveal(options = {}) {
  const ref = useRef(null);
  const {
    threshold = 0.2,
    rootMargin = '0px',
    once = true
  } = options;

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          element.classList.add('is-visible');
          if (once) {
            observer.unobserve(element);
          }
        } else if (!once) {
          element.classList.remove('is-visible');
        }
      },
      { threshold, rootMargin }
    );

    observer.observe(element);

    return () => observer.disconnect();
  }, [threshold, rootMargin, once]);

  return ref;
}

// 使用例
export default function AnimatedCard() {
  const ref = useScrollReveal({ threshold: 0.3 });

  return (
    <div ref={ref} className="reveal">
      <h2>タイトル</h2>
      <p>コンテンツ</p>
    </div>
  );
}
```

### Staggered Animation（時差アニメーション）

```javascript
function initStaggeredReveal(options = {}) {
  const {
    selector = '.reveal',
    delay = 100, // ミリ秒
    threshold = 0.2
  } = options;

  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry, index) => {
      if (entry.isIntersecting) {
        // 遅延を追加
        setTimeout(() => {
          entry.target.classList.add('is-visible');
        }, index * delay);

        observer.unobserve(entry.target);
      }
    });
  }, { threshold });

  const elements = document.querySelectorAll(selector);
  elements.forEach(el => observer.observe(el));

  return observer;
}
```

## 注意点

### パフォーマンス

- `will-change` は必要な場合のみ使用（メモリ消費に注意）
- transform と opacity 以外のプロパティはリフローを引き起こす可能性
- 大量の要素を監視する場合は、threshold を調整

### アクセシビリティ

- prefers-reduced-motion を必ず対応
- アニメーションはあくまで装飾。コンテンツへのアクセスを妨げない
- スクリーンリーダーユーザーには影響なし

### ブラウザサポート

- IntersectionObserver は IE11 非対応
- ポリフィルが必要な場合: [intersection-observer polyfill](https://www.npmjs.com/package/intersection-observer)

## 応用例

- カードのリスト表示
- ギャラリーの画像読み込み
- セクションごとのフェードイン
- パララックス効果との組み合わせ

## 参考リンク

- [Intersection Observer API - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)
- [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API)
